#include "codegen.h"
#include "instructions.h"
#include "mem_mac.h"
#include "parser.h"
#include "ast.h"

#include <string.h>

#define panic(MSG) \
    printf("%s", MSG); \
    exit(1);

void pushStackFrame(struct CodeGenerator* cg);
void popStackFrame(struct CodeGenerator* cg);

byte* compileExpr(struct CodeGenerator* cg, struct Node* expr);
byte* compileInt(struct CodeGenerator* cg, struct Node* intExpr);
byte* compileBinOp(struct CodeGenerator* cg, struct Node* infixExpr);

void intToByteArray(uint64_t value, byte* outputBuffer);

struct CodeGenerator* newCodeGenerator(char* filename) {
    struct CodeGenerator* retVal = new(struct CodeGenerator);

    retVal->parser = new(struct Parser);
    struct Parser tempParser = newParser(filename);
    memcpy(retVal->parser, &tempParser, sizeof(struct Parser));

    retVal->currentStatementCode = NULL;

    retVal->symbolStackDepth = 0;
    retVal->symbolStack = NULL; /*TODO*/

    retVal->OpImmMap = newMap();
    setPair(retVal->OpImmMap, "+", ADD_A_IMM);
    setPair(retVal->OpImmMap, "-", SUB_A_IMM);
    setPair(retVal->OpImmMap, "*", MUL_A_IMM);
    setPair(retVal->OpImmMap, "/", DIV_A_IMM);

    retVal->OpABMap = newMap();
    setPair(retVal->OpABMap, "+", ADD_A_B);
    setPair(retVal->OpABMap, "-", SUB_A_B);
    setPair(retVal->OpABMap, "*", MUL_A_B);
    setPair(retVal->OpABMap, "/", DIV_A_B);

    return retVal;
}

void deleteCodeGenerator(struct CodeGenerator* cg) {
    deleteParser(*cg->parser);
    free(cg->parser);

    for (int i = 0; i < cg->symbolStackDepth; i++) {
        deleteSymTab(cg->symbolStack[i]);
    }
    
    if (cg->symbolStack != NULL)
        free(cg->symbolStack);

    if (cg->currentStatementCode != NULL)
        free(cg->currentStatementCode);

    deleteMap(cg->OpImmMap);
    deleteMap(cg->OpABMap);
}

void compileCurrentStatement(struct CodeGenerator* cg) {
    ParseStmt(cg->parser);
    struct Node* statement = cg->parser->curNode;

    free(cg->currentStatementCode);
    cg->codeSize = 0;

    cg->currentStatementCode = compileExpr(cg, statement);
}

byte* compileExpr(struct CodeGenerator* cg, struct Node* expr) {
    switch (expr->nt) {
    case INT_NT:
        return compileInt(cg, expr);
        break;
    case BINOP_NT:
        return compileBinOp(cg, expr);
        break;
    default:
        printf("Could not generate code for expression type '%d'\n", expr->nt);
        exit(1);
    }
}

void copyIntToByteArray(uint64_t value, byte* outputBuffer) {
    memcpy(outputBuffer, &value, sizeof(uint64_t));
}

#define SIZEOF_LDA_IMM 9
byte* compileInt(struct CodeGenerator* cg, struct Node* intExpr) {
    int val = intExpr->as.Int->Value;
    byte* instructions = new_array(byte, SIZEOF_LDA_IMM);
    
    instructions[0] = LDA_IMM;
    copyIntToByteArray((uint64_t) val, instructions + 1);

    cg->codeSize = SIZEOF_LDA_IMM;

    return instructions;
}

byte* compileBinOp(struct CodeGenerator* cg, struct Node* infixExpr) {
    int compositeCodeSize = 0; //Total size of all the code generated by this expression

    //Compile LHS
    byte* output_code = compileExpr(cg, infixExpr->as.BinOp->LHS);
    compositeCodeSize += cg->codeSize;

    byte opcode;
    switch (infixExpr->as.BinOp->RHS->nt) {
    case INT_NT:
        opcode = lookup(cg->OpImmMap, infixExpr->as.BinOp->Op);
        expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + 1 + sizeof(uint64_t));
        output_code[compositeCodeSize++] = opcode;
        
        int val = infixExpr->as.BinOp->RHS->as.Int->Value;
        copyIntToByteArray((uint64_t) val, output_code + compositeCodeSize);
        compositeCodeSize += sizeof(uint64_t);

        break;
    default:
        opcode = lookup(cg->OpABMap, infixExpr->as.BinOp->Op);
        expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + 1);
        output_code[compositeCodeSize++] = PUSH_A;

        byte* rhs_code = compileExpr(cg, infixExpr->as.BinOp->RHS);
        expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + cg->codeSize);
        memcpy(output_code + compositeCodeSize, rhs_code, cg->codeSize);
        compositeCodeSize += cg->codeSize;

        expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + 3);

        output_code[compositeCodeSize++] = LDB_A;
        output_code[compositeCodeSize++] = POP_A;
        output_code[compositeCodeSize++] = opcode;
    }

    cg->codeSize = compositeCodeSize; 

    return output_code;
}
