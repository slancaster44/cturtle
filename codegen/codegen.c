#include "codegen.h"
#include "instructions.h"
#include "mem_mac.h"
#include "parser.h"
#include "ast.h"

#include <string.h>

void pushStackFrame(struct CodeGenerator* cg);
void popStackFrame(struct CodeGenerator* cg);

byte* compileExpr(struct CodeGenerator* cg, struct Node* expr);
byte* compileInt(struct CodeGenerator* cg, struct Node* intExpr);
byte* compileBool(struct CodeGenerator* cg, struct Node* boolExpr);
byte* compileBinOp(struct CodeGenerator* cg, struct Node* infixExpr);
byte* compileIfElse(struct CodeGenerator* cg, struct Node* ifelStmt);
byte* compileWhile(struct CodeGenerator* cg, struct Node* whileStmt);

void intToByteArray(uint64_t value, byte* outputBuffer);

struct CodeGenerator* newCodeGenerator(char* filename) {
    struct CodeGenerator* retVal = new(struct CodeGenerator);

    retVal->parser = new(struct Parser);
    struct Parser tempParser = newParser(filename);
    memcpy(retVal->parser, &tempParser, sizeof(struct Parser));

    retVal->currentStatementCode = NULL;

    retVal->symbolStackDepth = 0;
    retVal->symbolStack = NULL; /*TODO*/

    retVal->curAddress = 0;

    retVal->OpImmMap = newMap();
    setPair(retVal->OpImmMap, "+", ADD_A_IMM);
    setPair(retVal->OpImmMap, "-", SUB_A_IMM);
    setPair(retVal->OpImmMap, "*", MUL_A_IMM);
    setPair(retVal->OpImmMap, "/", DIV_A_IMM);
    setPair(retVal->OpImmMap, "==", EQ_A_IMM);
    setPair(retVal->OpImmMap, "!=", NE_A_IMM);
    setPair(retVal->OpImmMap, "||", OR_A_IMM);
    setPair(retVal->OpImmMap, "&&", AND_A_IMM);


    retVal->OpABMap = newMap();
    setPair(retVal->OpABMap, "+", ADD_A_B);
    setPair(retVal->OpABMap, "-", SUB_A_B);
    setPair(retVal->OpABMap, "*", MUL_A_B);
    setPair(retVal->OpABMap, "/", DIV_A_B);
    setPair(retVal->OpABMap, "==", EQ_A_B);
    setPair(retVal->OpABMap, "!=", NE_A_B);
    setPair(retVal->OpABMap, "||", OR_A_B);
    setPair(retVal->OpABMap, "&&", AND_A_B);

    return retVal;
}

void deleteCodeGenerator(struct CodeGenerator* cg) {
    deleteParser(*cg->parser);
    free(cg->parser);

    for (int i = 0; i < cg->symbolStackDepth; i++) {
        deleteSymTab(cg->symbolStack[i]);
    }
    
    if (cg->symbolStack != NULL)
        free(cg->symbolStack);

    if (cg->currentStatementCode != NULL)
        free(cg->currentStatementCode);

    deleteMap(cg->OpImmMap);
    deleteMap(cg->OpABMap);
}

void compileCurrentStatement(struct CodeGenerator* cg) {
    ParseStmt(cg->parser);
    struct Node* statement = cg->parser->curNode;

    free(cg->currentStatementCode);
    cg->codeSize = 0; /* TODO: Is this necessary? */

    cg->currentStatementCode = compileExpr(cg, statement);
    cg->curAddress += cg->codeSize;
}

byte* compileExpr(struct CodeGenerator* cg, struct Node* expr) {
    switch (expr->nt) {
    case INT_NT:
        return compileInt(cg, expr);
        break;
    case BOOL_NT:
        return compileBool(cg, expr);
        break;
    case BINOP_NT:
        return compileBinOp(cg, expr);
        break;
    case IFEL_NT:
        return compileIfElse(cg, expr);
        break;
    case WHILE_NT:
        return compileWhile(cg, expr);
        break;
    default:
        node_panic(expr, "Could not generate code for '%s'\n", expr->tok->Contents);
    }
}

void copyIntToByteArray(uint64_t value, byte* outputBuffer) {
    memcpy(outputBuffer, &value, sizeof(uint64_t));
}

#define SIZEOF_LDA_IMM 9
byte* compileInt(struct CodeGenerator* cg, struct Node* intExpr) {
    int val = intExpr->as.Int->Value;
    byte* instructions = new_array(byte, SIZEOF_LDA_IMM);
    
    instructions[0] = LDA_IMM;
    copyIntToByteArray((uint64_t) val, instructions + 1);

    cg->codeSize = SIZEOF_LDA_IMM;

    return instructions;
}

byte* compileBool(struct CodeGenerator* cg, struct Node* boolExpr) {
    uint64_t val = (uint64_t) boolExpr->as.Bool->Value;
    byte* instructions = new_array(byte, SIZEOF_LDA_IMM);

    instructions[0] = LDA_IMM;
    copyIntToByteArray(val, instructions + 1);

    cg->codeSize = SIZEOF_LDA_IMM;

    return instructions;
}

byte* compileBinOp(struct CodeGenerator* cg, struct Node* infixExpr) {

    int compositeCodeSize = 0; //Total size of all the code generated by this expression

    //Compile LHS
    byte* output_code = compileExpr(cg, infixExpr->as.BinOp->LHS);
    compositeCodeSize += cg->codeSize;

    /* TODO: Implement type checking */

    byte opcode;
    int val;
    switch (infixExpr->as.BinOp->RHS->nt) {
    case INT_NT:
        opcode = lookup(cg->OpImmMap, infixExpr->as.BinOp->Op);
        expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + 1 + sizeof(uint64_t));
        output_code[compositeCodeSize++] = opcode;
        
        val = infixExpr->as.BinOp->RHS->as.Int->Value;
        copyIntToByteArray((uint64_t) val, output_code + compositeCodeSize);
        compositeCodeSize += sizeof(uint64_t);

        break;
    case BOOL_NT:
        opcode = lookup(cg->OpImmMap, infixExpr->as.BinOp->Op);
        expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + 1 + sizeof(uint64_t));
        output_code[compositeCodeSize++] = opcode;
        
        val = infixExpr->as.BinOp->RHS->as.Bool->Value;
        copyIntToByteArray((uint64_t) val, output_code + compositeCodeSize);
        compositeCodeSize += sizeof(uint64_t);

        break;
    case BINOP_NT:

        opcode = lookup(cg->OpABMap, infixExpr->as.BinOp->Op);
        expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + 1);
        output_code[compositeCodeSize++] = PUSH_A;

        byte* rhs_code = compileExpr(cg, infixExpr->as.BinOp->RHS);
        expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + cg->codeSize);
        memcpy(output_code + compositeCodeSize, rhs_code, cg->codeSize);
        compositeCodeSize += cg->codeSize;

        expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + 3);

        output_code[compositeCodeSize++] = LDB_A;
        output_code[compositeCodeSize++] = POP_A;
        output_code[compositeCodeSize++] = opcode;
        break;
    default:
        node_panic(infixExpr, "Invalid RHS\n");
        break;
    }

    if (opcode == 255) 
        node_panic(infixExpr, "Could not compile for operator '%s'\n", infixExpr->as.BinOp->Op);


    cg->codeSize = compositeCodeSize; 

    return output_code;
}

byte* compileBlock(struct CodeGenerator* cg, struct Block* b) {
    int compositeCodeSize = 0;
    byte* output_code = NULL;

    for (int i = 0; i < b->numStatements; i++) {
        byte* curStmt = compileExpr(cg, b->Statements[i]);

        if (output_code == NULL) {
            compositeCodeSize += cg->codeSize;
            output_code = new_array(byte, compositeCodeSize);
            memcpy(output_code, curStmt, compositeCodeSize);
        } else {
            expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + cg->codeSize);
            memcpy(output_code+compositeCodeSize, curStmt, cg->codeSize);
            compositeCodeSize += cg->codeSize;
        }
    }

    cg->codeSize = compositeCodeSize;
    return output_code;
}

byte* compileIfElse(struct CodeGenerator* cg, struct Node* ifelStmt) {
    int compositeCodeSize = 0;
    byte* output_code = NULL;

    int numBackpatches = 0;
    int* backpatches = NULL;

    for (int i = 0; i < ifelStmt->as.IfEl->numBlocks; i++) {
        byte* conditionCode = compileExpr(cg, ifelStmt->as.IfEl->Conditions[i]);
        int conditionSize = cg->codeSize;

        byte* blockCode = compileBlock(cg, ifelStmt->as.IfEl->Blocks[i]);
        int blockSize = cg->codeSize;

        int thisBranchSize = blockSize + conditionSize + ((1 + sizeof(qword)) * 2);

        byte* jmpInstruction = new_array(byte, 1 + sizeof(qword));
        jmpInstruction[0] = JPA_Z_OFF;
        copyIntToByteArray((uint64_t) cg->curAddress + compositeCodeSize + thisBranchSize, jmpInstruction + 1);
    
        byte* jmpOutInstruction = new_array(byte, 1 + sizeof(qword));
        jmpOutInstruction[0] = JP_OFF;

        byte* copyToAddr;
        if (output_code == NULL) {
            output_code = new_array(byte, thisBranchSize);
            copyToAddr = output_code;
        } else {
            expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + thisBranchSize);
            copyToAddr = output_code + compositeCodeSize;
        }

        memcpy(copyToAddr, conditionCode, conditionSize);
        memcpy(copyToAddr + conditionSize, jmpInstruction, 1 + sizeof(qword));
        memcpy(copyToAddr + conditionSize + 1 + sizeof(qword), blockCode, blockSize);
        memcpy(copyToAddr + conditionSize + ((1 + sizeof(qword)) * 2), jmpOutInstruction, 1 + sizeof(qword));

        if (backpatches == NULL) {
            backpatches = new_array(int, ++numBackpatches);
            backpatches[numBackpatches-1] = compositeCodeSize + conditionSize + blockSize + (1+sizeof(qword)) + 1;
        } else {
            expand_array(int, backpatches, numBackpatches, ++numBackpatches);
            backpatches[numBackpatches-1] = compositeCodeSize + conditionSize + blockSize + (1+sizeof(qword)) + 1;
        }

        compositeCodeSize += thisBranchSize;
    }

    if (ifelStmt->as.IfEl->ElseBlock != NULL) {
        byte* elseCode = compileBlock(cg, ifelStmt->as.IfEl->ElseBlock);
        int elseSize = cg->codeSize;

        expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + elseSize);
        memcpy(output_code + compositeCodeSize, elseCode, elseSize);
        compositeCodeSize += elseSize;
    }


    for (int i = 0; i < numBackpatches; i++) {
        copyIntToByteArray(cg->curAddress + compositeCodeSize, output_code + backpatches[i]);
    }

    cg->codeSize = compositeCodeSize;
    return output_code;
}

byte* compileWhile(struct CodeGenerator* cg, struct Node* whileStmt) {
    byte* blockCode = compileBlock(cg, whileStmt->as.While->Block);
    int blockSize = cg->codeSize;

    byte* conditionCode = compileExpr(cg, whileStmt->as.While->Condition);
    int conditionSize = cg->codeSize;

    byte* jmpInstruction = new_array(byte, 1 + sizeof(qword));

    byte* output_code = new_array(byte, blockSize + conditionSize + 1 + sizeof(qword));
    if (whileStmt->as.While->isDoWhile) {
        memcpy(output_code, blockCode, blockSize);
        memcpy(output_code + blockSize, conditionCode, conditionSize);

        jmpInstruction[0] = JPA_OFF;
        copyIntToByteArray((uint64_t) cg->curAddress, jmpInstruction + 1);
        memcpy(output_code + blockSize + conditionSize, jmpInstruction, 1 + sizeof(qword));
    } else {
        memcpy(output_code, conditionCode, conditionSize);
    
        jmpInstruction[0] = JPA_Z_OFF;
        copyIntToByteArray((uint64_t) cg->curAddress + blockSize + 1 + sizeof(qword) + conditionSize, jmpInstruction + 1);
        memcpy(output_code + conditionSize, jmpInstruction, 1 + sizeof(qword));

        memcpy(output_code + conditionSize + 1 + sizeof(qword), blockCode, blockSize);
    }

    cg->codeSize = conditionSize + blockSize + 1 + sizeof(qword);
    return output_code;
}