#include "codegen.h"
#include "instructions.h"
#include "mem_mac.h"
#include "parser.h"
#include "ast.h"

#include <string.h>

byte* compileExpr(struct CodeGenerator* cg, struct Node* expr);
byte* compileInt(struct CodeGenerator* cg, struct Node* intExpr);
byte* compileBool(struct CodeGenerator* cg, struct Node* boolExpr);
byte* compileBinOp(struct CodeGenerator* cg, struct Node* infixExpr);
byte* compileIfElse(struct CodeGenerator* cg, struct Node* ifelStmt);
byte* compileWhile(struct CodeGenerator* cg, struct Node* whileStmt);
byte* compileLet(struct CodeGenerator* cg, struct Node* letStmt);
byte* compileIdent(struct CodeGenerator* cg, struct Node* identStmt);

void intToByteArray(uint64_t value, byte* outputBuffer);

struct CodeGenerator* newCodeGenerator(char* filename) {
    struct CodeGenerator* retVal = new(struct CodeGenerator);

    retVal->parser = new(struct Parser);
    struct Parser tempParser = newParser(filename);
    memcpy(retVal->parser, &tempParser, sizeof(struct Parser));

    retVal->currentStatementCode = NULL;

    retVal->curAddress = 0;

    retVal->OpImmMap = newMap();
    setPair(retVal->OpImmMap, "+", ADD_A_IMM);
    setPair(retVal->OpImmMap, "-", SUB_A_IMM);
    setPair(retVal->OpImmMap, "*", MUL_A_IMM);
    setPair(retVal->OpImmMap, "/", DIV_A_IMM);
    setPair(retVal->OpImmMap, "==", EQ_A_IMM);
    setPair(retVal->OpImmMap, "!=", NE_A_IMM);
    setPair(retVal->OpImmMap, "||", OR_A_IMM);
    setPair(retVal->OpImmMap, "&&", AND_A_IMM);


    retVal->OpABMap = newMap();
    setPair(retVal->OpABMap, "+", ADD_A_B);
    setPair(retVal->OpABMap, "-", SUB_A_B);
    setPair(retVal->OpABMap, "*", MUL_A_B);
    setPair(retVal->OpABMap, "/", DIV_A_B);
    setPair(retVal->OpABMap, "==", EQ_A_B);
    setPair(retVal->OpABMap, "!=", NE_A_B);
    setPair(retVal->OpABMap, "||", OR_A_B);
    setPair(retVal->OpABMap, "&&", AND_A_B);

    return retVal;
}

void deleteCodeGenerator(struct CodeGenerator* cg) {
    deleteParser(*cg->parser);
    free(cg->parser);

    if (cg->currentStatementCode != NULL)
        free(cg->currentStatementCode);

    deleteMap(cg->OpImmMap);
    deleteMap(cg->OpABMap);
}

void compileCurrentStatement(struct CodeGenerator* cg) {
    ParseStmt(cg->parser);
    struct Node* statement = cg->parser->curNode;

    free(cg->currentStatementCode);
    cg->codeSize = 0; /* TODO: Is this necessary? */

    cg->currentStatementCode = compileExpr(cg, statement);
    cg->curAddress += cg->codeSize;
}

byte* compileExpr(struct CodeGenerator* cg, struct Node* expr) {
    switch (expr->nt) {
    case INT_NT:
        return compileInt(cg, expr);
        break;
    case BOOL_NT:
        return compileBool(cg, expr);
        break;
    case BINOP_NT:
        return compileBinOp(cg, expr);
        break;
    case IFEL_NT:
        return compileIfElse(cg, expr);
        break;
    case WHILE_NT:
        return compileWhile(cg, expr);
        break;
    case LET_NT:
        return compileLet(cg, expr);
        break;
    case IDENT_NT:
        return compileIdent(cg, expr);
        break;
    default:
        node_panic(expr, "Could not generate code for '%s'\n", expr->tok->Contents);
    }
}

void copyIntToByteArray(uint64_t value, byte* outputBuffer) {
    memcpy(outputBuffer, &value, sizeof(uint64_t));
}

#define SIZEOF_LDA_IMM 9
byte* compileInt(struct CodeGenerator* cg, struct Node* intExpr) {
    int val = intExpr->as.Int->Value;
    byte* instructions = new_array(byte, SIZEOF_LDA_IMM);
    
    instructions[0] = LDA_IMM;
    copyIntToByteArray((uint64_t) val, instructions + 1);

    cg->codeSize = SIZEOF_LDA_IMM;

    return instructions;
}

byte* compileBool(struct CodeGenerator* cg, struct Node* boolExpr) {
    uint64_t val = (uint64_t) boolExpr->as.Bool->Value;
    byte* instructions = new_array(byte, SIZEOF_LDA_IMM);

    instructions[0] = LDA_IMM;
    copyIntToByteArray(val, instructions + 1);

    cg->codeSize = SIZEOF_LDA_IMM;

    return instructions;
}

byte* compileBinOp(struct CodeGenerator* cg, struct Node* infixExpr) {

    int compositeCodeSize = 0; //Total size of all the code generated by this expression

    //Compile LHS
    byte* output_code = compileExpr(cg, infixExpr->as.BinOp->LHS);
    compositeCodeSize += cg->codeSize;

    /* TODO: Implement type checking */

    byte opcode;
    int val;
    switch (infixExpr->as.BinOp->RHS->nt) {
    case INT_NT:
        opcode = lookup(cg->OpImmMap, infixExpr->as.BinOp->Op);
        expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + 1 + sizeof(uint64_t));
        output_code[compositeCodeSize++] = opcode;
        
        val = infixExpr->as.BinOp->RHS->as.Int->Value;
        copyIntToByteArray((uint64_t) val, output_code + compositeCodeSize);
        compositeCodeSize += sizeof(uint64_t);

        break;
    case BOOL_NT:
        opcode = lookup(cg->OpImmMap, infixExpr->as.BinOp->Op);
        expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + 1 + sizeof(uint64_t));
        output_code[compositeCodeSize++] = opcode;
        
        val = infixExpr->as.BinOp->RHS->as.Bool->Value;
        copyIntToByteArray((uint64_t) val, output_code + compositeCodeSize);
        compositeCodeSize += sizeof(uint64_t);

        break;
    case BINOP_NT:

        opcode = lookup(cg->OpABMap, infixExpr->as.BinOp->Op);
        expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + 1);
        output_code[compositeCodeSize++] = PUSH_A;

        byte* rhs_code = compileExpr(cg, infixExpr->as.BinOp->RHS);
        expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + cg->codeSize);
        memcpy(output_code + compositeCodeSize, rhs_code, cg->codeSize);
        free(rhs_code);
        compositeCodeSize += cg->codeSize;

        expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + 3);

        output_code[compositeCodeSize++] = LDB_A;
        output_code[compositeCodeSize++] = POP_A;
        output_code[compositeCodeSize++] = opcode;
        break;
    default:
        node_panic(infixExpr, "Invalid RHS\n");
        break;
    }

    if (opcode == 255) 
        node_panic(infixExpr, "Could not compile for operator '%s'\n", infixExpr->as.BinOp->Op);


    cg->codeSize = compositeCodeSize; 

    return output_code;
}

byte* compileBlock(struct CodeGenerator* cg, struct Block* b) {
    int compositeCodeSize = 0;
    byte* output_code = NULL;

    for (int i = 0; i < b->numStatements; i++) {
        byte* curStmt = compileExpr(cg, b->Statements[i]);

        if (output_code == NULL) {
            compositeCodeSize += cg->codeSize;
            output_code = new_array(byte, compositeCodeSize);
            memcpy(output_code, curStmt, compositeCodeSize);
        } else {
            expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + cg->codeSize);
            memcpy(output_code+compositeCodeSize, curStmt, cg->codeSize);
            compositeCodeSize += cg->codeSize;
        }
        free(curStmt);
    }

    if (b->numPrimativeVarsInScope != 0) {
        expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + 1 + sizeof(qword));
        output_code[compositeCodeSize] = SHRINK_STACK_SIZE;
        copyIntToByteArray((uint64_t) b->numPrimativeVarsInScope, output_code + 1 + compositeCodeSize);
        compositeCodeSize += 1 + sizeof(qword);
    }

    cg->codeSize = compositeCodeSize;
    return output_code;
}

#define SIZE_OF_JMP_INS 9
byte* compileIfElse(struct CodeGenerator* cg, struct Node* ifelStmt) {
    int compositeCodeSize = 0;
    byte* output_code = NULL;

    int numBackpatches = 0;
    qword* backpatches = NULL;

    /* Code Layout:
     * <condition code>
     * jpa z, <next condition>
     * <block code>
     * jp <end of all blocks>
     * ...
     */
    for (int i = 0; i < ifelStmt->as.IfEl->numBlocks; i ++) {
        byte* conditionCode = compileExpr(cg, ifelStmt->as.IfEl->Conditions[i]);
        int conditionCodeSize = cg->codeSize;

        byte jpToNextCondition[SIZE_OF_JMP_INS];
        jpToNextCondition[0] = JPA_Z_OFF;

        byte* blockCode = compileBlock(cg, ifelStmt->as.IfEl->Blocks[i]);
        int blockSize = cg->codeSize;

        byte jpToEndOfBlocks[SIZE_OF_JMP_INS];
        jpToEndOfBlocks[0] = JP_OFF;

        int sizeOfThisBranch = conditionCodeSize + blockSize + (2*SIZE_OF_JMP_INS);
        qword endingAddressOfThisBlock = cg->curAddress + sizeOfThisBranch;

        /*Insert address to jpa z, <next condition> instruction*/
        copyIntToByteArray(endingAddressOfThisBlock, jpToNextCondition + 1);

        /* Make note of location to back pattch <end of all blocks> address
         * when we know it
         */
        numBackpatches++;
        if (backpatches == NULL) {
            backpatches = new_array(qword, numBackpatches);
        } else {
            expand_array(qword, backpatches, numBackpatches-1, numBackpatches);
        }
        backpatches[i] = compositeCodeSize + sizeOfThisBranch - sizeof(qword);

        //Insert code into output
        if (output_code == NULL) {
            output_code = new_array(byte, sizeOfThisBranch);
        } else {
            expand_array(byte, output_code, compositeCodeSize, compositeCodeSize + sizeOfThisBranch);
        }
        
        byte* copyToAddr = output_code;
        
        memcpy(copyToAddr, conditionCode, conditionCodeSize);
        copyToAddr += conditionCodeSize;
        memcpy(copyToAddr, jpToNextCondition, SIZE_OF_JMP_INS);
        copyToAddr += SIZE_OF_JMP_INS;
        memcpy(copyToAddr, blockCode, blockSize);
        copyToAddr += blockSize;
        memcpy(copyToAddr, jpToEndOfBlocks, SIZE_OF_JMP_INS);

        compositeCodeSize += sizeOfThisBranch;

        /* Cleanup */
        free(blockCode);
        free(conditionCode);
    }

    if (ifelStmt->as.IfEl->ElseBlock != NULL) {
        byte* elseBlock = compileBlock(cg, ifelStmt->as.IfEl->ElseBlock);
        int elseBlockSize = cg->codeSize;

        expand_array(byte, output_code, compositeCodeSize, compositeCodeSize+elseBlockSize);
        memcpy(output_code+compositeCodeSize, elseBlock, elseBlockSize);

        compositeCodeSize += elseBlockSize;
        free(elseBlock);
    }

    for (int i = 0; i < numBackpatches; i++) {
        output_code[backpatches[i]] = cg->curAddress + compositeCodeSize;
    }

    cg->codeSize = compositeCodeSize;
    return output_code;
}

byte* compileWhile(struct CodeGenerator* cg, struct Node* whileStmt) {
    byte* blockCode = compileBlock(cg, whileStmt->as.While->Block);
    int blockSize = cg->codeSize;

    byte* conditionCode = compileExpr(cg, whileStmt->as.While->Condition);
    int conditionSize = cg->codeSize;

    byte* jmpInstruction = new_array(byte, 1 + sizeof(qword));

    byte* output_code = new_array(byte, blockSize + conditionSize + 1 + sizeof(qword));
    if (whileStmt->as.While->isDoWhile) {
        memcpy(output_code, blockCode, blockSize);
        memcpy(output_code + blockSize, conditionCode, conditionSize);

        jmpInstruction[0] = JPA_OFF;
        copyIntToByteArray((uint64_t) cg->curAddress, jmpInstruction + 1);
        memcpy(output_code + blockSize + conditionSize, jmpInstruction, 1 + sizeof(qword));
    } else {
        memcpy(output_code, conditionCode, conditionSize);
    
        jmpInstruction[0] = JPA_Z_OFF;
        copyIntToByteArray((uint64_t) cg->curAddress + blockSize + 1 + sizeof(qword) + conditionSize, jmpInstruction + 1);
        memcpy(output_code + conditionSize, jmpInstruction, 1 + sizeof(qword));

        memcpy(output_code + conditionSize + 1 + sizeof(qword), blockCode, blockSize);
    }

    free(blockCode);
    free(conditionCode);
    free(jmpInstruction);

    cg->codeSize = conditionSize + blockSize + 1 + sizeof(qword);
    return output_code;
}

byte* compileLet(struct CodeGenerator* cg, struct Node* letStmt) {
    byte* output_code = compileExpr(cg, letStmt->as.Let->Value);
    int codeSize = cg->codeSize;

    expand_array(byte, output_code, codeSize, codeSize + 1 + sizeof(qword));
    output_code[codeSize++] = ENSURE_STACK_SIZE;
    copyIntToByteArray((uint64_t) letStmt->as.Let->StackLocation+1, output_code + codeSize);
    codeSize += sizeof(qword);

    expand_array(byte, output_code, codeSize, codeSize + 1 + sizeof(qword));
    output_code[codeSize++] = INSERT_STACK_IMM_A;
    copyIntToByteArray((uint64_t) letStmt->as.Let->StackLocation, output_code + codeSize);
    codeSize += sizeof(qword);

    cg->codeSize = codeSize;
    return output_code;
}

byte* compileIdent(struct CodeGenerator* cg, struct Node* identStmt) {
    byte* output_code = new_array(byte, 1 + sizeof(qword));

    output_code[0] = LDA_STACK_IMM;
    copyIntToByteArray((uint64_t) identStmt->as.Ident->StackLocation, output_code + 1);

    cg->codeSize = 1 + sizeof(qword);
    return output_code;
}